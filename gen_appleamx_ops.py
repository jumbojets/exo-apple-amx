from pathlib import Path
from string import Template

# Supported by both Exo and Apple AMX
TYPE_BYTES = {"f16": 2, "f32": 4, "f64": 8, "i8": 1, "i32": 4}

def lanes(dtype): return 64 // TYPE_BYTES[dtype]

LD_TPL = Template(r'''
@instr("AMX_LD${pool_upper}(&{src_data}, {dst_data}, 0);")
def apple_amx_ld${pool_lower}_${dtype}(dst: [$dtype][$N] @ APPLE_AMX_POOL_${pool_upper}, src: [$dtype][$N] @ DRAM):
  assert stride(dst, 0) == 1
  assert stride(src, 0) == 1
  for i in seq(0, $N):
    dst[i] = src[i]''')

STZ_TPL = Template(r'''
@instr("AMX_ST${pool_upper}(&{dst_data}, {src_data}, 0);")
def apple_amx_st${pool_lower}_${dtype}(dst: [$dtype][$N] @ DRAM, src: [$dtype][$N] @ APPLE_AMX_POOL_${pool_upper}):
    assert stride(dst, 0) == 1
    assert stride(src, 0) == 1
    for i in seq(0, $N):
        dst[i] = src[i]''')

FMA_MAT_TML = Template(r'''
@instr("AMX_FMA${type_bits}({srcx_data} * 64, {srcy_data} * 64, {dst_data}, 0);")
def apple_amx_fma${type_bits}_mat(dst: [$dtype][$N, $N] @ APPLE_AMX_POOL_Z, srcx: [$dtype][$N] @ APPLE_AMX_POOL_X, srcy: [$dtype][$N] @ APPLE_AMX_POOL_Y):
  assert stride(dst, 1) == 1
  assert stride(srcx, 0) == 1
  assert stride(srcy, 0) == 1
  for i in seq(0, $N):
    for j in seq(0, $N):
      dst[i, j] += srcx[i] * srcy[j]''')

FMA_VEC_TPL = Template(r'''
@instr("AMX_FMA${type_bits}({srcx_data} * 64, {srcy_data} * 64, {dst_data}, 1 << 63);")
def apple_amx_fma${type_bits}_vec(dst: [$dtype][$N] @ APPLE_AMX_POOL_Z, srcx: [$dtype][$N] @ APPLE_AMX_POOL_X, srcy: [$dtype][$N] @ APPLE_AMX_POOL_Y):
  assert stride(dst, 0) == 1
  assert stride(srcx, 0) == 1
  assert stride(srcy, 0) == 1
  for i in seq(0, $N):
    dst[i] += srcx[i] * srcy[i]''')

def main():
  out = []
  out.append("# AUTOGENERATED FILE. DO NOT EDIT.")
  out.append("from __future__ import annotations")
  out.append("from exo import *")
  out.append("from exo.stdlib.stdlib import stride")
  out.append("from appleamx_pools import APPLE_AMX_POOL_X, APPLE_AMX_POOL_Y, APPLE_AMX_POOL_Z")

  for dtype in TYPE_BYTES.keys():
    for letter in ("X", "Y", "Z"):
      opts = {"pool_upper": letter, "pool_lower": letter.lower(), "dtype": dtype, "N": lanes(dtype)}
      out.append(LD_TPL.substitute(opts))
      out.append(STZ_TPL.substitute(opts))

  for dtype in ("f16", "f32", "f64"):
    opts = {"type_bits": TYPE_BYTES[dtype] * 8, "dtype": dtype, "N": lanes(dtype)}
    out.append(FMA_MAT_TML.substitute(opts))
    out.append(FMA_VEC_TPL.substitute(opts))

  Path("appleamx_ops.py").write_text("\n".join(out))

if __name__ == "__main__":
  main()
